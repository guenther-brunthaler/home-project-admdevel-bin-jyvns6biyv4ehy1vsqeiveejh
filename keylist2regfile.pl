# Generates a REGEDIT version 4 '.reg'-File from a given text file
# containing a list of registry key subtrees.
#
# For optimum results, the key should be sorted in ascending order,
# because then redundant entries can safely be optimized away.
#
# $Id: /trunk/Org/SysAdmin/Crossplatform/bin/keylist2regfile.pl 2647 2006-08-26T07:45:40.216781Z gb  $


use strict;
use File::Temp qw(tempdir);
use File::Spec::Functions qw(catfile);
use Fcntl qw(:DEFAULT :seek);
use FileLinesWindow_590FC250_9D95_11D9_BFF0_00A0C9EF1631;
use ShellCmd_1A7E54C0_9EFF_11D9_BFF3_00A0C9EF1631;
use StringUtil_ED0113F0_9F17_11D9_BFF3_00A0C9EF1631 qw(is_prefix);


my $fn= shift or die "specify registry key subtree list file!";
open IN, '<', $fn or die "cannot open '$fn': $!";
my $out= $fn;
$out =~ s/ (?: \. [^.]+ )? $ /-settings.reg/x;
my($lw, $fh, $td, $exp, $mrg, $problems, $key);
$td= tempdir '~reg-export_XXXXXX', TMPDIR => 1, CLEANUP => 1;
$exp= catfile $td, 'exported.reg';
$mrg= catfile $td, 'merged.reg';
open MRG, '+>', $mrg or die "cannot create '$mrg': $!";
my $sh= new Lib::ShellCmd;
while (defined($key= <IN>)) {
   chomp $key;
   $key =~ s/^ \s* (.*?) \s* $/$1/x;
   eval {
      $sh->call(qq!reg.exe EXPORT "$key" "$exp" > NUL!);
      open EXP, '<:encoding(UTF-16)', $exp or die "Cannot open '$exp': $!";
      {
         local $/= "\x0d\x0a";
         die unless <EXP> =~ /^Windows Registry Editor Version 5/;
         $_= <EXP>; chomp; die unless /^$/;
         while (defined($_= <EXP>)) {
            chomp; print MRG "$_\n";
         }
      }
      close EXP or die $!;
   };
   if ($@) {
      print STDERR qq'(problem in key "$key")\n';
      $problems= 1;
   }
}
close IN or die $!;
seek MRG, 0, SEEK_SET or die $!;
open OUT, '>', $out or die "cannot create '$out': $!";
print OUT
   "REGEDIT4\n"
   , "; this file has been generated by "
   , (File::Spec->splitpath($0))[-1], "\n"
   , "; on ", scalar(localtime), "\n\n"
;
{
   my $in= new Lib::FileLinesWindow
      -input => *MRG{IO}, qw/-virtual ? -after 2/
   ;
   while (defined($_= $in->readline)) {
      if (/ ^ \s* \[ ([^]]+) \] \s* $ /x) {
         my $k= $1;
         if (
            $in->line(1) =~ /^\s*$/
            && $in->line(2) =~ / ^ \s* \[ ([^]]+) \] \s* $ /x
            && is_prefix($k, $1)
            && substr($1, length($k), 1) eq '\\'
         ) {
            $in->skip;
            next;
         }
      }
      print OUT $_;
   }
}
close OUT or die "cannot finish writing '$out': $!";
close MRG or die "cannot close '$mrg': $!";
$sh->call("$ENV{COMSPEC} /C PAUSE") if $problems;
