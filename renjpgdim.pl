# $Id: /trunk/Org/SysAdmin/Crossplatform/bin/renjpgdim.pl 2647 2006-08-26T07:45:40.216781Z gb  $
# Create JPEG file hardlinks based on image dimensions.


use strict;
use FindBin;
use lib "$FindBin::Bin/..";
use File::Spec;
use Getopt::Std;
use ExpandFilelist_57D9097A_926F_11D6_951B_009027319575;


#
# http://de.wikipedia.org/wiki/JPEG
#
# Die JPEG-Dateien sind in Segmente unterteilt. Die Segmente sind
# generell in  folgender Form aufgebaut: Ein FF xx s1 s2 leitet den Tag
# ein. FF steht für  Hexadezimal 255. Das xx bestimmt die Art des Tags.
# 256 * s1 + s2 gibt die Länge  des Segmentes an. In den Segmenten
# können sich weitere Bilder verbergen, oft  ein kleines Thumbnail-Bild
# für die schnelle Vorschau.
# 
# FF xx  Bezeichnung/Art
# FF D8  Start Of Image (SOI)
# FF C0  Info ($height, $width)= unpack 'X 2n', $segment
# FF E0  JFIF tag
# FF C4  Define Huffman Table (DHT)
# FF DB  Define Quantisation Table (DQT)
# FF E1  EXIF Daten
# FF EE  Oft für Copyright Einträge
# FF En  n=2..F allg. Zeiger
# FF FE  Kommentare
# FF D9  End of Image (EOI)
#


our($opt_p, $opt_v, $opt_h, $opt_f, $opt_c, $opt_u, $opt_s, $opt_x);
$opt_s= '';
$opt_u= qq!"%s" %3\$u %4\$u %5\$s\n!;
die <<"END" if !getopts('pxvfhc:u:s:') || $opt_h;
$0 - create JPEG file hardlinks based on image dimensions

Usage: $0 [ options ] <file_pattern> ...
where
<file_pattern>:
$Lib::ExpandFilelist::ExpandFilelist::HELP

Supported options:
-h: Display this help
-p: Print filenames and dimensions rather than creating hardlinks
-f: Force hardlinking - overwrite existing hardlinks
-c <cond>: Specify a condition for printing/hardlinking
-u <format>: Specify a used-defined output format for -p
-s <string>: Specify a separator for -u
-x: Execute the string generated by -u as a command
-v: Be verbose

When -p is in effect, for each processed JPEG file a line of information
is displayed, consisting of the following (space separated) fields:
* file name in double quotes
* width of the image in pixels
* height of the image in pixels
* orientation indicator character:
  'H': ('horizontal') if width > height
  'V' ('vertical') if height > width
  'S' (square) if width = height
* optionally additional fields in future enhancements of the tool

Option -c accepts a conditional expression as its argument, which
allows to specify a condition for processing the JPEG file.
('Processing' here means printing or hardlinking, depending on '-p'.)
The condition can be any valid Perl expression and may refer to
the variables '\$file', '\$width', '\$height' and '\$orientation'.
'\$file' contains the original file name.
For security reasones, no other variables may be used. Nor may potentially
dangerous functions be invoked such as 'eval'.

The -u option takes a printf-format string as its input (including the
Perl enhancements of printf), and should format the output line to be
displayed (including any "\\n" if desired at the end of the line).
The following printf-arguments are available:
* 1st argument: source file name
* 2nd argument: target file name
* 3rd argument: width
* 4th argument: height
* 5th argument: orientation character

The "\\", "\\n", "\\t", "\x??" and "\\0" escapes are also supported.

if -s is also specified, the string will be inserted between all outputs
generated by -u, but *neither* before the first nor the last output.

The following example will print all target names as a comma separated list:

$0 -p "-s, " "-u%2\$s"

Instead of -p, -x can also be used together with -u. In this case
the formatted string is executed as an external command. Processing is
aborted immediately if the command returns a nonzero return status.

If both -x and -p are specified, -p takes precedence over -x, but a "\\n"
will be added to each output line.

This allows to display commands with -p -x first, and then executing them
with -x only.

$0
written in 2004 by Guenther Brunthaler
END
my(@f, $i, $d, $sz, $n, $id, $vol, $dir, $bn, $newname, $process);
my($orientation, $width, $height, $nfirst, $cmd, $qcmd);
if ($opt_c) {
   die "Expression must be limited to allowed context" if $opt_c =~ /
      \b (?: eval | do | require | use | sub | goto | package) \b
      | [\%\@&] | ::
      | \$ (?! width | height | file | orientation )
   /x;
}
if ($opt_u) {
   $opt_u =~ s!
      \\ (
         [ \\ n t 0 ]
         | x [[:xdigit:]]{2}
      )
   !
      do {
         my $r= $1;
         if (length($r) == 2) {
            $r= hex $r;
         }
         else {
            $r =~ tr|0nt|\0\n\t|;
         }
         $r;
      }
   !xeg;
}
$opt_u.= "\n" if $opt_p && $opt_x;
@f= @ARGV;
ExpandFilelist(\@f, -expand_globs => 1, -log => $opt_v);
die "No files" unless @f;
foreach my $file (sort @f) {
   # Read file.
   open IN, '<', $file or die "Cannot open '$file': $!";
   binmode IN or die $!;
   # Assume the format segment will be near the beginning of the file.
   die unless read IN, $d, 0x10000;
   close IN or die;
   # Find starting tag.
   for ($i= 0; $i + 1 < length $d; ++$i) {
      last if unpack("\@$i n", $d) == 0xffd8;
   }
   $i+= 2;
   die unless $i < length $d;
   for ($n= 1; ; ++$n) {
      $id= unpack "\@$i n", $d;
      $i+= 2;
      if ($id == 0xffc0) {
         $i+= 2;
         ($height, $width)= unpack "\@$i x n2", $d;
         last;
      }
      die if $id == 0xffd9;
      $sz= unpack "\@$i n", $d;
      $i+= 2;
      $sz-= 2;
      $i+= $sz;
      die if $i + 2 > length $d;
   }
   $orientation= $width > $height ? 'H' : $height > $width ? 'V' : 'S';
   if ($opt_c) {
      $process= eval $opt_c;
      die "Error evaluating condition: $@" if $@;
      next unless $process;
   }
   ($vol, $dir, $bn)= File::Spec->splitpath($file);
   die unless $bn =~ s/ (?= (?: \. [^.]* )? $ ) /_${width}x$height/x;
   $newname= File::Spec->catpath($vol, $dir, $bn);
   if ($opt_p) {
      if ($nfirst) {print $opt_s}
      else {$nfirst= 1}
      printf $opt_u, $file, $newname, $width, $height, $orientation;
   }
   elsif ($opt_x) {
      $qcmd
         = $cmd
         = sprintf $opt_u, $file, $newname, $width, $height, $orientation
      ;
      $qcmd =~ s/\\/\\\\/g;
      print "Executing '$cmd'\n" if $opt_v;
      unless (system $qcmd) {
         if ($? == -1) {
            die "failed to execute '$cmd': $!\n";
         }
         elsif ($? & 127) {
            die
            sprintf "command '$cmd' died with signal %d (%s coredump)"
               , ($? & 127), ($? & 128) ? 'with' : 'without'
            ;
         }
      }
   }
   else {
      print "Hardlinking '$file' -> '$newname'\n" if $opt_v;
      if (-e $newname) {
         if ($opt_f) {
            if ((stat _)[3] < 2) {
               die "Will not overwrite '$newname': Is not already hardlinked";
            }
            print "(after removing old hardlink '$newname')\n" if $opt_v;
            unless (unlink($newname) == 1) {
               die "Cannot remove existing old hardlink '$newname': $!";
            }
         }
         else {
            die "Target '$newname' already exists (consider using -f)";
         }
      }
      link $file, $newname or die "Could hardlink '$file' -> '$newname': $!";
   }
}
